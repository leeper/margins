<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Marginal Effects Plots}
-->

# Marginal Effects Plots #

Using `margins` to calculate marginal effects enables several kinds of plotting. The built-in `plot` method for objects of class `margins` creates simple diagnostic plots for examining the output of `margins` in visual rather than tabular format. It is also possible to use the output of `margins` to produce more typical marginal effects plots that show the marginal effect of one variable across levels of another variable. This vignette walks through the `plot` method and then shows how to produce marginal effets plots using base graphics.

## The `plot` Method ##

The **margins** package implements a `plot` method for objects of class `margins`. This produces a plot similar (in spirit) to the output of Stata's `marginsplot`. It is highly customizable, but is meant primarily as a diagnostic tool to examine the results of `margins`. It simply produces, by default, a plot of marginal effects along with 95% confidence intervals for those effects. The confidence level can be modified using the `levels` argument, which is vectorized to allow multiple levels to be specified simultaneously.

```{r}
library("margins")
x <- lm(mpg ~ cyl + hp * wt, data = mtcars)
m <- margins(x)
plot(m[[1]], level = c(0.67, 0.95, 0.99), horiz = TRUE, main = "Average Marginal Effects")
```

## Plotting Marginal Effects ##

There are two common ways of visually representing the substantive results of a regression model: (1) fitted values plots, which display the fitted conditional mean outcome across levels of a covariate, and (2) marginal effects plots, which display the estimated marginal effect of a variable across levels of a covariate. This section discusses both approaches. Fitted value plots can be created using R's `predict` function, while marginal effect plots can be produced using an object of class of `margins` and `plot` (or the plotting functions from another package, such as **ggplot**, **lattice**, etc.).

For example, to examine the predicted values at different levels of an indicator (dummy) variable, we can estimate a regression model that includes an interaction between weight (`wt`) and transmission (`am`) and then use the `predict` function to obtain predicted values at each level of the indicator and then `plot` the results. In the below example, `am` is an indicator for whether a car is automatic (0) or manual (1). First the model is estimated. Second, a temporary dataset is created that represents the mean values of all observed variables. One could specify alternative values here (because, e.g., the mean of the cylinders variable [`cyl`] doesn't necessarily make substantive sense), but I adopt this approach for simplicity. Then, this dataset is modified a few times to create a list of datasets with different specified values of the weight variable (`wt`).

```{r, results = "hold"}
x <- lm(mpg ~ cyl + wt * am, data = mtcars)

# data at means
tmp <- as.data.frame(t(colMeans(mtcars)))

# two versions of temporary data
tmp0 <- within(tmp, am <- 0)
tmp1 <- within(tmp, am <- 1)

# values of `wt` to predict/plot against based on range of original data
tmp_wt <- seq(min(mtcars$wt), max(mtcars$wt), .05)

# generate predictions
p <- sapply(tmp_wt, function(z) {
    c(p0 = unlist(predict(x, newdata = within(tmp0, wt <- z), se.fit = TRUE)[1:2]),
      p1 = unlist(predict(x, newdata = within(tmp1, wt <- z), se.fit = TRUE)[1:2]))
})

# plot
plot(NA, xlim = range(tmp_wt), ylim = c(0, 1.04*max(p)), 
     xlab = "wt", ylab = "mpg")

# automatic
lines(tmp_wt, p[1,], col = "red", lwd = 2)
lines(tmp_wt, p[1,] + (1.96*p[2,]), col = "red", 
      lty = 2, lwd = 1)                               # automatic (upper 95% CI)
lines(tmp_wt, p[1,] - (1.96*p[2,]), col = "red", 
      lty = 2, lwd = 1)                               # automatic (lower 95% CI)

# manual
lines(tmp_wt, p[3,], col = "blue", lwd = 2)
lines(tmp_wt, p[3,] + (1.96*p[4,]), col = "blue", 
      lty = 2, lwd = 1)                               # manual (upper 95% CI)
lines(tmp_wt, p[3,] - (1.96*p[4,]), col = "blue", 
      lty = 2, lwd = 1)                               # manual (lower 95% CI)
```

The slopes of the predicted value lines are the marginal effect of `wt` when `am == 0` and `am == 1`. We can obtain these slopes using `margins` and specifying the `at` argument:

```{r}
margins(x, at = list(am = 0:1))
```

The above plot also highlights, though, that the marginal effect of transmission `am` differs across values of `wt`. As weight increases, the effect of a manual transmission goes from positive (where the blue line is higher than the red line) to negative (where the red line exceed the blue line). Because `am` is an indicator variable, the marginal effect is simply the first-difference (i.e., the difference between the two sets of values we just predicted that are now stored in `p`). We can plot the differences between predicted values to see how the marginal effect of `am` increases (in negative magnitude):

```{r, results = "hold"}
me <- p[3,] - p[1,]
plot(tmp_wt, me, type = "l", ylim = c(-15,15), lwd = 2, xlab = "wt", ylab = "Marginal Effect at Means")
abline(h = 0, col = 'gray')
s <- sqrt(p[4,]^2 + p[2,]^2)
lines(tmp_wt, me + 1.96 * s, lty = 2, lwd = 1)
lines(tmp_wt, me - 1.96 * s, lty = 2, lwd = 1)
```

The marginal effect of `am` is now clear. It is positive when weight is low, indistinguishable from zero for much of the range of weight, and then negative when weight is very high.

But, that's a lot of code to create a plot of marginal effects. Using `margins`, we can produce an essentially identical plot much more easily. Starting again from the same regression model estimation, we can produce the plot quite easily:

```{r, results = "hold"}
x <- lm(mpg ~ cyl + wt * am, data = mtcars)

# calculate marginal effects at specified `wt`s and extract results
tmp_wt <- seq(min(mtcars$wt), max(mtcars$wt), .05)
m <- margins(x, at = list(wt = tmp_wt))
me <- sapply(m, function(z) summary(z)["am",c(2,6,7)])

# draw plot
plot(tmp_wt, me[1,], type = "l", ylim = c(-15,15), lwd = 2, xlab = "wt", ylab = "Marginal Effect at Means")
abline(h = 0, col = 'gray')
lines(tmp_wt, me[2,], lty = 2, lwd = 1)
lines(tmp_wt, me[3,], lty = 2, lwd = 1)
```


It is also possible to do this with **ggplot2**. Starting from the list of marginal effects results (`m`) from above, we can replace the base plotting code with simple ggplot2 code:

```{r, results = "hold"}
me <- do.call(rbind, lapply(m, function(z) summary(z)["am",c(2,6,7)]))
me$x <- as.numeric(row.names(me))
names(me) <- c("e","l","u","x") # rename columns for simplicity

library("ggplot2")
ggplot(me) + geom_line(aes(x=x, y=e, group=1)) + 
   geom_hline(yintercept=0, linetype=2, color="dark gray") +
   geom_line(aes(x=x, y=u, group=1), stat="identity", alpha=.3, color="black") + 
   geom_line(aes(x=x, y=l, group=1), stat="identity", alpha=.3, color="black") + 
   xlab("wt") + ylab("Marginal Effect") + theme_bw() 
```


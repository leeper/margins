% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cplot.R
\name{cplot}
\alias{cplot}
\title{Conditional predicted value and average marginal effect plots for models}
\usage{
cplot(object, x = NULL, dx = NULL, what = c("prediction", "effect",
  "classprediction", "stackedprediction"), type = c("response", "link"),
  vcov = stats::vcov(object), data = NULL, level = 0.95,
  draw = TRUE, xvals = NULL, z = NULL, zvals = NULL, n = 25,
  rugplot = TRUE, at = NULL, ...)
}
\arguments{
\item{object}{A statistical model object}

\item{x}{The name of the variable to show on the x-axis}

\item{dx}{The name of the variable whose effect should be plotted}

\item{what}{The quantity to plot: 'prediction', 'effect', 'classprediction',
or 'stackedprediction'}

\item{type}{'response' or 'link'}

\item{vcov}{the variance-covariance matrix used to calculate confidence intervals}

\item{data}{data.frame over which to calculate individual marginal effects
or predictions}

\item{level}{The confidence level required (used to draw uncertainty
bounds).}

\item{draw}{A logical (default \code{TRUE}), specifying whether to draw the
plot. If \code{FALSE}, the data used in drawing are returned as a list of
data.frames. This might be useful if you want to plot using an alternative
plotting package (e.g., ggplot2). Also, if set to value \dQuote{add}, then
the resulting data is added to the existing plot.}

\item{xvals}{A numeric vector of values at which to calculate predictions or
marginal effects, if \code{x} is numeric. By default, it is calculated from
the data using \code{\link{seq_range}}. If \code{x} is a factor, this is
ignored, as is \code{n}.}

\item{z}{name of the third dimension variable over which quantities should
be plotted (as facets).}

\item{zvals}{discrete values of the z variable over which to plot}

\item{n}{An integer specifying the number of points across \code{x} at which
to calculate the predicted value or marginal effect, when \code{x} is
numeric. Ignored otherwise.}

\item{rugplot}{logical include a rugplot at the bottom of the graph}

\item{at}{Currently ignored.}

\item{\dots}{Additional arguments such as \code{colour}, \code{linetype},
\code{size}, \code{shape}, \code{fill}, \code{alpha}. These will be passed
to \code{ggplot2} geom functions to alter the style of the plot.  If `x` is
a factor, these arguments will be passed to
\code{\link[ggplot2]{geom_pointrange}}. If `x` is numeric, these arguments
will be passed to \code{\link[ggplot2]{geom_line}} and
\code{\link[ggplot2]{geom_ribbon}}.  The \code{alpha} and \code{fill}
arguments are not passed to \code{geom_line}. The \code{colour} argument is
not passed to \code{geom_ribbon}.}
}
\value{
A ggplot2 object. Use \code{draw = FALSE} to simply generate the
data structure for use elsewhere.
}
\description{
Draw one or more conditional effects plots reflecting
  model coefficients, or a function to perform the estimation with
  \code{model} as its only argument.
}
\details{
Note that when \code{what = "prediction"}, the plots show
predictions holding values of the data at their mean or mode, whereas when
\code{what = "effect"} average marginal effects (i.e., at observed values)
are shown.

When examining generalized linear models (e.g., logistic regression models),
confidence intervals for predictions can fall outside of the response scale
(again, for logistic regression this means confidence intervals can exceed
the (0,1) bounds). This is consistent with the behavior of
\code{\link[stats]{predict}} but may not be desired. The examples (below)
show ways of constraining confidence intervals to these bounds.

The overall aesthetic is somewhat similar to to the output produced by the
\code{marginalModelPlot()} function in the
\bold{\href{https://cran.r-project.org/package=car}{car}} package.
}
\examples{
\dontrun{
require('datasets')
# prediction from several angles
m <- lm(Sepal.Length ~ Sepal.Width, data = iris)
cplot(m)

# marginal effect of 'Petal.Width' across 'Petal.Width'
m <- lm(Sepal.Length ~ Sepal.Width * Petal.Width * I(Petal.Width ^ 2), 
        data = head(iris, 50))
cplot(m, x = "Petal.Width", what = "effect", n = 10)

# factor independent variables
mtcars[["am"]] <- factor(mtcars[["am"]])
m <- lm(mpg ~ am * wt, data = mtcars)
## predicted values for each factor level
cplot(m, x = "am")
## marginal effect of each factor level across numeric variable
cplot(m, x = "wt", dx = "am", what = "effect")

# non-linear model
m <- glm(am ~ wt*drat, data = mtcars, family = binomial)
cplot(m, x = "wt") # prediction (response scale)
cplot(m, x = "wt") # prediction (link scale)
if (require("ggplot2")) {
  # prediction (response scale, constrained to [0,1])
  cplotdat <- cplot(m, x = "wt", type = "link", draw = FALSE)
  ggplot(cplotdat, aes(x = xvals, y = plogis(yvals))) + 
         geom_line(lwd = 1.5) + 
         geom_line(aes(y = plogis(upper))) + 
         geom_line(aes(y = plogis(lower)))


# marginal effect of 'Petal.Width' across 'Sepal.Width'
## without drawing the plot
## this might be useful if you want even more control over the plots
tmp <- cplot(m, x = "Sepal.Width", dx = "Petal.Width", 
             what = "effect", n = 10, draw = FALSE)
}

# effects on linear predictor and outcome
cplot(m, x = "drat", dx = "wt", what = "effect", type = "link")
cplot(m, x = "drat", dx = "wt", what = "effect", type = "response")

# ordinal outcome
if (require("MASS")) {
  # x is a factor variable
  house.plr <- polr(Sat ~ Infl + Type + Cont, weights = Freq, 
                    data = housing)
  ## predicted probabilities
  cplot(house.plr)
  ## cumulative predicted probabilities
  cplot(house.plr, what = "stacked")
  ## ggplot2 example
  if (require("ggplot2")) {
    ggplot(cplot(house.plr), aes(x = xvals, y = yvals, group = level)) + 
      geom_line(aes(color = level))
  }

  # x is continuous
  cyl.plr <- polr(factor(cyl) ~ wt, data = mtcars)
  cplot(cyl.plr, col = c("red", "purple", "blue"), what = "stacked")
  cplot(cyl.plr, what = "class")
}

}
}
\seealso{
\code{\link{plot.margins}}, \code{\link{persp.lm}}
}
\keyword{graphics}
